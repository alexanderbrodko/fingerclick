<!DOCTYPE html>
<html>
	<head>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/synaptic/1.1.4/synaptic.min.js" integrity="sha512-nPPVw7EH/K4lr+WhkZHqsR2ZxKB7ROCLGLLdmHGR4vHdv/c+fYluZACzQqRQWGD5ehCBnlrxHzrQYNwKT319bA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="fingerclicknn.js"></script>
		<style>
			body {
				width: 1036px;
			}
		</style>
	</head>
	<body>
		<button onclick="start()">Start using mic</button>
		<script type="text/javascript">

let myNetwork;

try {
	let loadedNetworkJSON = JSON.parse(localStorage.getItem('myNetwork'));
	myNetwork = synaptic.Network.fromJSON(loadedNetworkJSON);
} catch(e) {
	let inputLayer = new synaptic.Layer(128);
	let hiddenLayer = new synaptic.Layer(64);
	let outputLayer = new synaptic.Layer(1);

	inputLayer.project(hiddenLayer);
	hiddenLayer.project(outputLayer);

	myNetwork = new synaptic.Network({
		input: inputLayer,
		hidden: [hiddenLayer],
		output: outputLayer
	});
}

let trainer = new synaptic.Trainer(myNetwork);

function hslToRgb(h, s, l) {
    let r, g, b;

    if (s == 0) {
        r = g = b = l;
    } else {
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

function drawRectangleHSL(imgData, x, y, width, height, h, s, l) {
    let endX = x + width,
    	endY = y + height,
    	{ r, g, b } = hslToRgb(h, s, l),
    	data = imgData.data;

    for (let iy = y; iy < endY; iy++) {
        for (let ix = x; ix < endX; ix++) {
            let pixelIndex = (iy * imgData.width + ix) * 4;
            
            data[pixelIndex + 0] = r;
            data[pixelIndex + 1] = g;
            data[pixelIndex + 2] = b;
            data[pixelIndex + 3] = 255;
        }
    }
}

async function createCanvas(stream) {
	let context = new AudioContext();

	document.body.innerHTML = '<span></span><input type="checkbox" /><br /><canvas height="512" width="1024"></canvas><br /><button onclick="copyNNToClipboard()">Copy to clipboard</button><button onclick="loadFingerClickNN()">Load Finger Click NN</button><button onclick="clearSavedNN()">Clear saved data</button>';

	let can = document.querySelector('canvas'),
		ctx = can.getContext('2d'),
		imgData = ctx.createImageData(1024, 512),
		help = document.querySelector('span'),
		negativeTraining = document.querySelector('input'),
		button = document.querySelector('button');

	window.copyNNToClipboard = function () {
		let networkJSON = myNetwork.toJSON();
		let textarea = document.createElement("textarea");
		textarea.value = JSON.stringify(networkJSON);
		document.body.appendChild(textarea);
		textarea.select();
		document.execCommand('copy');
		document.body.removeChild(textarea);
	}

	window.loadFingerClickNN = function () {
		localStorage.setItem('myNetwork', window.FingerClickNNText);
		location.reload();
	}

	window.clearSavedNN = function () {
		localStorage.setItem('myNetwork', null);
		location.reload();
	}

	help.innerText = `Use LMB to mark spectrogram column as a negative sample, and CTRL+LMB as a positive sample. Click on spectrogram to save trained network in a localStorage. Use this checkbox when you need to train negative samples, and do not produce target sounds while it is checked:`;

	let input = context.createMediaStreamSource(stream);
	let analyser = context.createAnalyser();
	analyser.fftSize = 512;
	input.connect(analyser);

	let col = -1,
		XSCALE = 8,
		YSCALE = 2;

	can.onmousemove = e => {
		col = (e.offsetX / XSCALE) | 0;
		let row = ((can.height - e.offsetY) / YSCALE) | 0;
		let str = 'Col: ' + col + '\nFreq: ' + Math.floor(row / analyser.fftSize * context.sampleRate);

		if (data[col]) {
			str += '\nVal: ' + data[col].sample[row];
		}

		can.title = str;
	};

	let data = [];
	can.onclick = e => {
		col = (e.offsetX / XSCALE) | 0;
		if (data[col]) {
			trainer.train([ { input: data[col].sample, output: [ e.ctrlKey ? 1 : 0 ] } ], { rate: e.ctrlKey ? 0.1 : 0.075 });

			if (e.ctrlKey) {
				data[col].positiveTrained = true;
			} else {
				data[col].negativeTrained = true;
			}

			let networkJSON = myNetwork.toJSON();
			localStorage.setItem('myNetwork', JSON.stringify(networkJSON));
		}
	};

	let isUpdating = true;
	can.addEventListener('mouseover', () => isUpdating = false);
	can.addEventListener('mouseout', () => {
		isUpdating = true;
		col = -1;
	});

	(function update() {
		if (isUpdating) {
			let freqByteData = new Uint8Array(can.height);
			analyser.getByteFrequencyData(freqByteData);

			let sample = [];
			for (let i = 0; i < 256; i++) {
				sample[i] = freqByteData[i] / 255;
			}

			if (negativeTraining.checked) {
				trainer.train([ { input: sample, output: [ 0 ] } ], { rate: 0.02 });
			}

			let predictionGood = myNetwork.activate(sample)[0] > 0.9;

			if (negativeTraining.checked && predictionGood) {
				trainer.train([ { input: sample, output: [ 0 ] } ], { rate: 0.05 });
			}

			data.unshift({ sample, predictionGood, negativeTrained: negativeTraining.checked });

			let maxSamples = can.width / XSCALE;
			if (data.length > maxSamples) {
				data.length = maxSamples;
			}
		}

		for (let x = 0; x < data.length; x++) {
			let { sample, predictionGood, negativeTrained, positiveTrained } = data[x];

			for (let y = 0; y < sample.length; y++) {
				let value = sample[y],
					h = (250 - (value * 360) | 0) / 360,
					s = 1,
					l = 0.5;
				if (x === col) {
					if (value) {
						l = 0.8;
					} else {
						l = 1;
					}
				} else if (negativeTrained) {
					if (value) {
						l = value;
					} else {
						h = 0;
						s = 0.5;
						l = 0.3;
					}
				} else if (positiveTrained) {
					if (value) {
						l = value;
					} else {
						h = 120 / 360;
						s = 0.5;
						l = 0.5;
					}
				} else if (predictionGood) {
					l = 0.6;
				} else {
					if (value) {
						l = 0.5;
					} else {
						l = 0;
					}
				}
				drawRectangleHSL(imgData, x * XSCALE, can.height - y * YSCALE, XSCALE, YSCALE, h, s, l);
			}
		}

		ctx.putImageData(imgData, 0, 0);

		setTimeout(update, 10);
	})();
}

function start() {
	navigator.getUserMedia({ audio: true }, createCanvas, e => alert(e));
}

		</script>
	</body>
</html>

